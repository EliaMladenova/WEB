<!DOCTYPE html>
<html>

<head>
    <title>URL Rewriting</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="css/style.css">
    <script src="js/script.js"></script>
</head>

<body>
    
    <header>
        <a id="top" href="#top"></a>
        <section class="nav">
            <h1>URL Rewriting</h1>
            <section class="dropdwn">
                <button class="dropbtn">Теория</button>
                    <section class="content">  
                        <a href="#urlDef">Какво е URL? </a> 
                        <a href="#urlRewrDef">Какво е URL Rewriting?</a>
                        <a href="#rewritingBasic">Основни правила за пренаписване</a>
                    </section>
            </section>
            <section class="dropdwn">
                <button class="dropbtn">Методи за пренаписване</button>
                    <section class="content">
                        <a href="#regexEx">Чрез Регулярни изрази</a>
                        <a href="#flagsEx">Чрез Флагове</a>
                        <a href="#conditionsEx">Чрез Условия</a>
                        <a href="#flagsEx">Изключения и специални случаи</a>
                    </section>
            </section>
            <section class="dropdwn">
                <button class="dropbtn">Примери</button>
                    <section class="content">
                    <a href="#example1">Няколко прости примера</a>
                    <a href="#example2">Преместване на съдържание</a>
                    <a href="#example3">Сървърни променливи <i>(Server Variables)</i></a>
                    <a href="#example4">Работа с повече правила</a>
                    </section>
            </section>
            <section class="dropdwn">
                <button class="dropbtn"><a href="#resources">Източници</a></button>
            </section>
        </section>
    </header>
    <main>
        <section>
            <h2 id="urlDef">Какво е URL? <a href="#res1"><i>[1]</i></a> <a href="#res2"><i>[2]</i></a></h2>
            <p>URL (Uniform Resource Locator), също познат като интернет адрес, е вид URI и стандартизирана конвенция за именуване на документи, които са достъпни в Интернет.  
                URL има два основни компонента – идентификатор на протокола и име на ресурса, които са разделени от двуеточие ( <b>:</b> ) и две наклонени черти ( <b>//</b> ).                
            </p>
            
            <figure>

                <img src="img/url.png" class="images"/>
                <figcaption>На картинката е представено от какво е изграден един URL.</figcaption>
                
            </figure>
            
            <p><i>„http”</i> отговаря за Hypertext Transfer Protocol. Той показва на браузъра кой <b>протокол</b> да ползва, за да достъпи определена информация в домейна. Когато обаче е https, това означава, че информацията, която се праща чрез HTTP, е криптирана  и сигурна – т.е secure, откъдето идва и допълнителното s. Други примери за протоколи са File Transfer Protocol (FTP), Gopher и т.н Въпреки наличието на дрги протоколи, HTTPS е най-често срещаният и се е превърнал в стандарт за днешните уеб сайтове.</p>
            <p> Следващата част от URL е <i>“www“</i> означаваща World Wide Web или така нареченият <b>поддомейн (subdomain)</b>. Използва се за логическо разделение на даден уебсайт на категории. „www“ не е задължителна и може да се пропусне. Т.е дали ще напишете http://computerhope.com или http://www.computerhope.com, крайният резултат ще е един и същ. </p>
            <p> Следваща поред част е <b>домейнът (root domain)</b> и <b>наставката (domain suffix)</b>. Домейнът е основният идентификатор на сайта. За да можем да намерим даден сайт, е много важно правилно да сме изписали домейна. Наставката, или още <i>Top-Level-Domain (TLD)</i>, идентифицира характеристика на сайта – неговата цел, организацията, която го притежава, или географската област, откъдето произлиза. Например “.com” произлиза от commercial (търговски),  „.org“ от organization (организация), а “.co.uk” показва местоположение, а именно United Kingdom (Великобритания). </p>
            <p> <i>“/jargon/u/”</i> в примера от картинката са <b>директории (subfolder)</b>, показващи къде се намира тази страница в сървъра. Това са заявки към страницата да предостви определена категория или тип страница. </p>
            <p> На последно място в този пример е <i>„url.htm”</i>, което показва <b>реалната страница от домейна</b>, която сме посетили. <i>„.htm“</i> отговаря на <b>разширението на файла</b>, в случая HTML файл. Други срещани разширения са .html, .php, .xml, .gif и т.н. Както различните типове файлове на компютъра ни, така и тези различни разширения изпълняват различна роля. </p>
        </section>
        <section>
            <h2 id="urlRewrDef">Какво е URL Rewriting? <a href="#res3"><i>[3]</i></a> <a href="#res4"><i>[4]</i></a> <a href="#res5"><i>[5]</i></a> </h2>
            <p> Пренаписването на URL е един от най-добрите и бързи методи за подобряване на използваемостта на даден сайт, както и по-лесното му намиране от търсачката и потребителя. Повечето динамични сайтове съдържат променливи в своите адреси, с което казват на сайта каква информация да покаже на потребителя. </p>
            <p> Чрез пренаписване на URL, самият адрес и ресурсите, до които води, могат да бъдат напълно независими един от друг. Макар и на практика да не са изцяло независими – URL адресът съдържа код, номер или име, което помага на системата за управление на съдържанието да потърси ресурса, на теория пренаписването предоставя пълно разделение. </p>
            <p> Като всяко нещо, пренаписването на URL също има плюсове и минуси. Плюсовете включват по-изчистени и описателни адреси, улесняващи както потребителите, така и търсачката. Също така сайтът може да продължи да ползва същите URL адреси, дори и да смени технологията, която ползва. Като недостатък може да се приеме, че ако потребител се опита да достъпи нова информация чрез модифициране на дадения URL, пренаписването може да възпрепядства конструкцията на персонализирани заявки заради липса на именувани променливи. </p>
        </section>
        <section>
            <h2 id="rewritingBasic">Основни правила за пренаписване <a href="#res3"><i>[3]</i></a> <a href="#res5"><i>[5]</i></a> <a href="#res7"><i>[7]</i></a> <a href="#res8"><i>[8]</i></a></h2>
            <p>Правилата за пренаписване формират част от конфигурацията на уебсайта на Apache сървъра и могат да бъдат поставени на различни места като част от виртуалната хост конфигурация. </p>
            <p>Възможността да имплементираш пренаписване на URL зависи от Уеб сървъра. Например Apache идва с вече инсталиран и активиран модул за пренаписване – mod_rewrite. От друга страна IIS, сървърът на Microsoft, не включва поодбен модул, но позволява добавянето на такава функционалност.</p>
            <p>Ще ви представя първо един лесен пример, с който да минем през основите на правилата за пренаписване на URL чрез <b>mod_rewrite.</b> </p>
            <p>Като за начало, нека си представим следния пример – имаме уебсайт и един PHP скрипт за една страница. Нейният URL адрес е: <section class="examples"> http://www.pets.com/pet_care_info_07_07_2008.php </section></p>
            <p>Нашата цел е да изчистим този адрес и да го направим удобен за търсене от търсачката и помнене от потребителите. Идеалният URL в този случай би бил: <section class="examples"> http://www.pets.com/pet-care/ </section> </p>
            <p>За да работи това, трябва да кажем на сървъра вътрешно да пренасочи всички заявки за <b>„pet-care“</b> към <b>"pet_care_info_07_07_2008.php"</b>. Искаме това да се случи вътрешно, защото не искаме самият URL в полето на браузъра да се изменя. </p>
            <p>За целта първо трябва да създадем текство документ с име <b>„.htaccess“ (Hypertext Access)</b>, който да съдържа нашите правила. Този документ ще бъде поставен в root директорията на сървъра, като ако вече има такъв документ е по-добре той да бъде редактиран, а не пренаписван. </p>
            <p>Apache сървърът предоставя конфигураця чрез <b>„.htaccess“</b> файлове. Тези файлове позволяват фино настройване на универсалите системни конфигурации на Apache, които са дефинирани в главния конфигурационен файл на Apache. Локализираните директиви трябва да оперират във файл на име „.htaccess“ като е важно потребителят да има необходимите разрешения за достъп и редактиране на този файл.</p>
            <p>Отделно този файл не трябва да доставя world write access, т.е най-сигурната настройка за разрешение е „644“, която позволява универсално четене, но писане само от потребител. Правилата, написани в .htaccess се прилагат за parent директорията и всички поддиректории. За да се приложат правилата за целия сайт, файлът трябва да се постави в root директорията на сайта.</p>
            <p>Файлът „.htaccess“ е конфигурационен за сървъра. Като такъв, той е много мощен и всяка грешка, дори и синтактична, може да доведе до неизправност. Ако има грешки, сървърът ще сигнализира – най-често с грешка с код „500“). Затова е важно да се правят резервни копия на всичко, свързано със сайта, включително и на оргиниалните htaccess файлове, преди някакви промени да бъдат направени. Използваме този файл с две цели – едната е да каже на Apache да включи пренаписващата машина (rewrite engine) и втората е да каже на Apache какво правило за пренаписване искаме да ползва. Във файла трябва да добавим следното:</p>
            <section class="rule">
                RewriteEngine On    # Turn on the rewriting engine <br>
                RewriteRule    ^pet-care/?$    pet_care_info_01_02_2008.php    [NC,L]    # Handle requests for "pet-care"
            </section>
            <p><i>Забележка:</i> Коментарите са важни за контролиране на всякакъв код. В този файл закоментирането става с помощта на <b>#</b>, като този знак се поставя преди всеки ред, който искаме да коментираме, т.е не може с # да се коментират множество редове. Също така RewriteEngine трябва да се ползва само веднъж в „.htaccess“ файл. </p>
            <p>Същинското пренаписване се случва благодарение на реда RewriteRule. Можем да го разделим на 5 части:</p>
            <ul>
                <li> <b>RewriteRule</b> – казва на Apache, че този ред се отнася само за едно правило</li>
                <li> <b>^/pet-care/?$</b> - това е шаблонът. Сървърът проверява адреса на всяка заявка да провери дали шаблонът съвпада. Ако да, Apache ще го размени със заместващата секция, която следва</li>
                <li> <b>pet_care_info_01_02_2003.php</b> – споменатата заместваща секция. При съвпадение Apache ползва този URL вместо заявения</li>
                <li> <b>[NC,L]</b> – „флагове“, които казват на Apache как да приложи правилото, като в този случай <b>NC</b> отговаря за case-sensitivity и по-точно да е case-insensitive, т.е да не се влияе от малки и големи букви, а <b>L</b> казва да не се прилагат други правила, ако това е използвано</li>
                <li> <b># Handle requests for "pet-care"</b> – както споменахме, всичко след # е коментар и като всеки друг коментар не е задължителен, а само препоръчителен </li>
            </ul>
        </section>
        <section>
            <h2 id="regexEx">Чрез Регулярни изрази <a href="#res3"><i>[3]</i></a></h2>
            <p> Горното правило позволява пренасочване на заявка за един URL, но по-интересно и полезно е когато се стигне до идентифициране и пренаписване на групи от URL, базирано на определени шаблони, които съдържат.</p>
            <p> За онагледяване на казаното, нека ползваме отново горния пример. Да кажем, че искаме да пренапишем всички налични URL по начина, по който пренаписахме горния. Съществуващият адрес е: <article class="examples">http://www.pets.com/show_a_product.php?product_id=7</article> <p>и искаме да го представим по следния начин:</p> <div class="examples">http://www.pets.com/products/7/</div> </p>
            <p> Очевидно вместо да пишем правило за всеки адрес, бихме предпочели да имаме едно правило, което да пренаписва всички адреси за идентификационния номер на продуктите, т.е искаме от <i>http://www.pets.com/show_a_product.php?product_id={a number}</i> да стане <i>http://www.pets.com/products/{a number}/</i>. </p>
            <p> Това е възможно чрез така наречените регулярни изрази. Това са шаблони, дефинирани в определен формат, който сървърът да може да разбере и да обработи правилно. Стандартен шаблон за избиране на числа изглежда така: <b>[0-9]+</b>, като в квадратните скоби се съдържа някакъв интервал от знаци, а <b>0-9</b> показва всички цифри. <b>Плюсът ( + )</b> от своя страна показва един или много предхождащи знаци, т.е този шаблон означава „една или повече цифри“.</p>
            <p> Улеснение от страна на сървъра е, че целият шаблон се третира като регулярен израз по подразбиране и няма нужда да се включва или активира допълнително.</p>
            <p> Цялостният вид на правилото би бил:</p>
            <article class="rule">RewriteRule    ^products/([0-9]+)/?$    show_a_product.php?product_id=$1    [NC,L]    # Handle product requests</article>
            <p>Слагаме шаблона в скоби, което ни позволява да направим референция от pattern частта към частта, която заместваме, тоест при пускане на заявка към products/5/, петицата ще се замести в <i>show_a_product.php?product_id=$1</i> на мястото на <b>$1</b>, което е плейсхолдър, като така бекенда ще разбере към кой URL точно се изпраща заявката.</p>
            <p>Важно уточнение при писането на регулярни изрази е наличието на така наречени „специални“ знаци. Това са знаци, които имат различно от обичайното значение за регулярния израз. </p>
            <figure>
                <figcaption>Някои от тези специални знаци включват:</figcaption>
                <table class="tableExceptions">
                    <tr>
                        <th id="firstTH">Символ</th>
                        <th id="secondTH">Значение</th>
                    </tr>
                    <tr>
                        <td>.</td>
                        <td>всякакъв знак</td>
                    </tr>
                    <tr>
                        <td>*</td>
                        <td>нула или повече от предхождащите</td>
                    </tr>
                    <tr>
                        <td>+</td>
                        <td>един или повече от предхождащите</td>
                    </tr>
                    <tr>
                        <td>{ }</td>
                        <td>минимум до максимум интервал</td>
                    </tr>
                    <tr>
                        <td>?</td>
                        <td>дали тестваният стринг е валиден файл</td>
                    </tr>
                    <tr>
                        <td>!</td>
                        <td>в началото на стринга означава отрицателен шаблон</td>
                    </tr>
                    <tr>
                        <td>^</td>
                        <td>начало на стринг или "отрицателен" ако е в началото на интервал</td>
                    </tr>
                    <tr>
                        <td>$</td>
                        <td>крайн на стринг</td>
                    </tr>
                    <tr>
                        <td>[ ]</td>
                        <td>съвпадение на съдържание</td>
                    </tr>
                    <tr>
                        <td>-</td>
                        <td>интервал, ако се ползва между [ ]</td>
                    </tr>
                    <tr>
                        <td>( )</td>
                        <td>група</td>
                    </tr>
                    <tr>
                        <td>|</td>
                        <td>или</td>
                    </tr>
                    <tr>
                        <td>\</td>
                        <td>"escape character", т.е знакът, с който се казва на регулярния израз, че даден знак не е специален</td>
                    </tr>
                  </table>
            </figure>
        </section>
        <section>
            <h2 id="flagsEx">Какво са Флагове? <a href="#res3"><i>[3]</i></a> <a href="#res6"><i>[6]</i></a></h2>
            <p> Флаговете се добавят в края на правилото, за да кажат на Apache как да интерпретира и управлява правилото. Поставят се в квадратни скоби <b>[ ]</b> и се разделят със запетая ( <b>,</b> ). </p>
            <p> Почти всеки флаг има кратка и дълга форма. Въпреки че най-често се използва кратката форма е добре да се знаят пълните форми, защото те улесняват запомнянето на предназначението на всеки флаг. Някои флагове приемат един или повече аргументи и не се влияят от малки и големи букви.</p>
            <figure>
            <figcaption> Ето и списък с някои флагове и техните значения:</figcaption>
            <table class="tableFlags">
                <tr>
                    <th id="firstTH">Име</th>
                    <th id="secondTH">Описание</th>
                </tr>
                <tr>
                    <td>C (<b>chain</b>)</td>
                    <td>свързан със следващото правило, т.е ако правилото съвпада, ще се продължи със следващото, обаче ако не съвпада всички следващи правила, които са свързани с това, се пропускат</td>
                </tr>
                <tr>
                    <td>CO (<b>cookie</b>)</td>
                    <td>позволява поставянето на специфична бисквитка; състои се от три задължителни и едно незадължително поле. <section class="flags">[CO=NAME:VALUE:DOMAIN:lifetime:path:secure:httponly]</section></td>
                </tr>
                <tr>
                    <td>E (<b>env</b>)</td>
                    <td>добавя стойност на променлива <section class="flags">[E=VAR:VAL] <br> [E=!VAR]</section></td>
                </tr>
                <tr>
                    <td>F (<b>forbidden</b>)</td>
                    <td>праща статус 403 на потребителя; F се ползва заедно с L, т.е отговорът се връща веднага и не се прилагат следващи правила</td>
                </tr>
                <tr>
                    <td>G (<b>gone</b>)</td>
                    <td>не същестува; праща статус 410; също като F G се ползва заедно с флага L</td>
                </tr>
                <tr>
                    <td>H (<b>handler</b>)</td>
                    <td>определена заявка се обработва от определен handler</td>
                </tr>
                <tr>
                    <td>L (<b>last</b>)</td>
                    <td>спира да обработва следващи правила, ако правилото съвпада</td>
                </tr>
                <tr>
                    <td>N (<b>next</b>)</td>
                    <td>правилата започват да отначалото, но с досегашния резултат; трябва да се ползва внимателно, защото може да доведе до цикли</td>
                </tr>
                <tr>
                    <td>NC (<b>nocase</b>)</td>
                    <td>с този флаг се показва, че правилото е case-insensitive, т.е не се влияе дали буквите са малки или големи/td>
                </tr>
                <tr>
                    <td>NE (<b>noescape</b>)</td>
                    <td>по подразбиране специалните знаци се конвертират до съответния им hexcode, а този флаг предотвратява това</td>
                </tr>
                <tr>
                    <td>P (<b>proxy</b>)</td>
                    <td>чрез този флаг се казва заявката да бъде изпълнена от mod_proxy и чрез proxy заявка; използва се заедно с L, т.е веднага се изпълнява и никое друго правило след това</td>
                </tr>
                <tr>
                    <td>PT (<b>passthrough</b>)</td>
                    <td>по подразбиране крайната цел се третира като път до файл, а този флаг казва да се третира като URI</td>
                </tr>
                <tr>
                    <td>R (<b>redirect</b>)</td>
                    <td>временно пренасочва към нов URL</td>
                </tr>
                <tr>
                    <td>R=301 (<b>redirect</b>)</td>
                    <td>перманентно пренасочва към нов URL</td>
                </tr>
                <tr>
                    <td>S (<b>skip</b>)</td>
                    <td>прескачане на определен брой правила</td>
                </tr>
                <tr>
                    <td>T (<b>type</b>)</td>
                    <td>поставя определен MIME type, с който ще се прати отговора</td>
                </tr>
              </table>
              </figure>
        </section>
        <section>
            <h2 id="conditionsEx">Чрез Условия <a href="#res3"><i>[3]</i></a></h2>
            <p>Правилата за пренаписване могат да бъдат предшествани от едно или повече условия и те могат да се пишат заедно. Това позволява да се приложат определени правила за определни заявки.</p>
            <p>Ето и пример за по-добро представяне на условията и как работят:</p>
            <article class="rule">
                <p>RewriteCond %{HTTP_HOST} ^addedbytes.com [NC] </p>
                <p>RewriteRule ^(.*)$ http://www.addedbytes.com/$1 [L,R=301]</p>
            </article>
            <p>Горното правило пренасочва всички заявки, без значение за какво, към същия URL на www.addedbytes.com. Без условието, правилото ще създаде цикъл като всяка заявка, която съвпада с правилото ще се праща към себе си. Така написано правилото е предназначено да пренасочва само заявки, където липсва “www” частта и условието подсигурява това да се случи.</p>
            <p>Условието работи по сходен начин като правилото. Започва с RewriteCond, което казва на mod_rewrite, че този ред се отнася за условие. Следва какво реално ще бъде тествано и шаблонът, по който ще се тества. На последно място се поставя флагът, точно като при RewriteRule. </p>
            <p>Стрингът, който се тества, т.е втората част от условието, може да бъде множество различни неща. В горния пример се тества домейнът, към който се праща заявката. Може също да се тества браузъра, IP адресът на потребителя и т.н.</p>
            <p>Шаблонът е почти същият като при правилото. Той може да не се интерпретира като такъв ако започва с определени знаци, например <,>,-.</p>
            <p>Към условията могат да се добавят флагове, както при правилата, но те са само два – NC и OR. Вторият се използва когато искаме да приложим правило ако едно от две условия съвпада и вместо да повтаряме условието, добавяме флаг OR.  Стандартното поведение на правилото, когато е предшествано от много условия, е, че ще се изпълни, ако всички условия съвпадат.</p>
        </section>
        <section>
            <h2 id="flagsEx">Изключения и специални случаи <a href="#res3"><i>[3]</i></a></h2>
            <p> Условията за пренаписване на URL могат да бъдат тествани по няколко различни начина – няма нужда да бъдат третирани като регулярни изрази, въпреки че предимно така се ползват. </p>
            <figure>
            <figcaption> Ето и няколко начина за обработване на условия:</figcaption>
            <table class="tableExceptions">
                <tr>
                    <th id="firstTH">Име</th>
                    <th id="secondTH">Описание</th>
                </tr>
                <tr>
                    <td><Шаблон</td>
                    <td>дали тестваният стринг е по-къс от шаблона</td>
                </tr>
                <tr>
                    <td>>Шаблон</td>
                    <td>дали тестваният стринг е по-дълъг от шаблона</td>
                </tr>
                <tr>
                    <td>=Шаблон</td>
                    <td>дали тестваният стринг е равен на шаблона</td>
                </tr>
                <tr>
                    <td>-d</td>
                    <td>дали тестваният стринг е валидна директория</td>
                </tr>
                <tr>
                    <td>-f</td>
                    <td>дали тестваният стринг е валиден файл</td>
                </tr>
                <tr>
                    <td>-s</td>
                    <td>дали тестваният стринг е валиден файл с размер, по-голям от 0</td>
                </tr>
                <tr>
                    <td>-l</td>
                    <td>дали тестваният стринг е symbolic link</td>
                </tr>
                <tr>
                    <td>-F</td>
                    <td>дали тестваният стринг е валиден и достъпен файл</td>
                </tr>
                <tr>
                    <td>-U</td>
                    <td>дали тестваният стринг е валиден и достъпен URL</td>
                </tr>
              </table>
              </figure>
        </section>
        <section>
            <h2 id="example1">Няколко прости примера <a href="#res3"><i>[3]</i></a></h2>
            <p>Като за начало нека разгледаме няколко прости примера за правила, изпълняващи стандартни команди:</p>
            <figure>

                <figcaption>За пренасочване на стар домейн към нов:</figcaption>
                <section class="rule">
                    <p>RewriteCond %{HTTP_HOST} old_domain.com [NC]</p>
                    <p>RewriteRule ^(.*)$ http://www.new_domain.com/$1 [L,R=301]</p>
                </section>
                
            </figure>
            <figure>

                <figcaption>За пренасочване на всички заявки, където липсва "www":</figcaption>
                <section class="rule">
                    <p>RewriteCond %{HTTP_HOST} ^domain.com [NC]</p>
                    <p>RewriteRule ^(.*)$ http://www.domain.com/$1 [L,R=301]</p>
                </section>
                
            </figure>
            <figure>

                <figcaption>За пренасочване на всички заявки, съдържащи "www":</figcaption>
                <section class="rule">
                    <p>RewriteCond %{HTTP_HOST} ^www.domain.com [NC]</p>
                    <p>RewriteRule ^(.*)$ http://www.new_domain.com/$1 [L,R=301]</p>
                </section>
                
            </figure>
            <figure>

                <figcaption>За пренасочване на стара страница към нова:</figcaption>
                <section class="rule">
                    <p>RewriteRule ^old-url.htm$ http://www.domain.com/new-url.htm [NC,R=301,L]</p>
                </section>
                
            </figure>
        </section>
        <section>
            <h2 id="example2">Преместване на съдържание <a href="#res3"><i>[3]</i></a></h2>
            <p>Нека разгледаме следния пример:</p>
            <section class="rule">RewriteRule    ^article/?$    http://www.new-domain.com/article/    [R,NC,L]    # Temporary Move</section>
            <p>Чрез добавяне на флага R се изменя работата на правилото. Вместо да се пренаписва вътрешно, Apache праща съобщение обратно към браузъра (HTTP хедър), което казва дали документът е преместен временно. Този хедър съдържа код "<b>302</b>", който показва, че преместването е временно.</p>
            <p>Ако искаме да преместим за постоянно даден URL, към R флага се добавя „<b>=301</b>“, с което Apache казва на браузъра да приема преместването за постоянно. За разлика от R, R=301 казва на браузъра да представи новия адрес в адрес бара.</p>
            <p>Нагледно това правило изглежда така:</p>
            <section class="rule">RewriteRule    ^article/?$    http://www.new-domain.com/article/    [R=301,NC,L]    # Permanent Move</section>
            <p>Това е и най-често ползваният метод за пренаписване на URL на елементи, които са преместени на нови адреси.</p>
        </section>
        <section>
            <h2 id="example3">Сървърни променливи <i>(Server Variables)</i>  <a href="#res3"><i>[3]</i></a></h2>
            <p>Сървърните промениви са селекция от елементи, които могат да бъдат тествани когато се пишат правила. Това позволява да се прилагат правила, базирани на всякакви заявени параметри, включително идентификатори на браузъра, препращащи адреси или множество от други стрингове.</p>
            <p>Променливите се записват по следния начин:</p>
            <section class="examples">%{VARIABLE_NAME}</section>
            <p>А <b>VARIABLE_NAME</b> може да бъде заменено например с HTTP_PROXY_CONNECTION / HTTP_REFERER / HTTP_COOKIE/ REMOTE_ADDR / REMOTE_HOST / SERVER_ADMIN / TIME_YEAR и т.н.</p>
        </section>
        <section>
            <h2 id="example4">Работа с повече правила  <a href="#res3"><i>[3]</i></a></h2>
            <p>Колкото по-сложни са сайтовете, толкова повече се усложняват и правилата. Това създава проблем, когато трябва да се решават конфликти между правила. Ако правилото само по себе си е правилно написано, то тогава има друго правило преди това, което съвпада с адреса и така адресът не се тества за новото добавено правило.</p>
            <p>Ще използвам 2 примера за по-добро представяне на проблема:</p>
            <section class="problems">
                <button id="exampleBtn" onclick="showExample1('ruleExamples1')">Пример №1</button>
                <section id="ruleExamples1">
                    <p>В този пример продуктовите страници и блога имат идентични шаблони. Второто правило няма да съвпадне с URL, защото всеки адрес, който би съвпаднал вече е съвпаднал с горното правило. </p>
                    <p>RewriteRule    ^([A-Za-z0-9-]+)/([A-Za-z0-9-]+)/?$    get_product_by_name.php?category_name=$1&product_name=$2    [NC,L]    # Process product requests</p>
                    <p>RewriteRule    ^([A-Za-z0-9-]+)/([A-Za-z0-9-]+)/?$    get_blog_post_by_title.php?category_name=$1&post_title=$2    [NC,L]    # Process blog posts</p>
                </section>
                <button id="exampleBtn" onclick="showSolution1('solution1')">Решение на Пример №1</button>
                <section id="solution1">
                    <p>Един начин за справяне с този проблем е като се добави допълнителна част към URL за обозначаване на типа заявка. Това се пише по следния начин:</p>
                    <p>RewriteRule    ^products/([A-Za-z0-9-]+)/([A-Za-z0-9-]+)/?$    get_product_by_name.php?category_name=$1&product_name=$2    [NC,L]    # Process product requests</p>
                    <p>RewriteRule    ^blog/([A-Za-z0-9-]+)/([A-Za-z0-9-]+)/?$    get_blog_post_by_title.php?category_name=$1&post_title=$2    [NC,L]    # Process blog posts</p>
                </section>
                <button id="exampleBtn" onclick="showExample2('ruleExamples2')">Пример №2</button>
                <section id="ruleExamples2">
                    <p>В някои случаи тази ситуация може да се избегне като се напишат по-точни правила. </p>
                    <p>Във втория пример са представени две правила, където се архивират постове по тема и по дата.</p>
                    <p>RewriteRule    ^([A-Za-z0-9-]+)/?$    get_archives_by_topic.php?topic_name=$1    [NC,L]    # Get archive by topic</p>
                    <p>RewriteRule    ^([A-Za-z0-9-]+)/?$    get_archives_by_year.php?year=$1    [NC,L]    # Get archive by year</p>
                </section>
                <button id="exampleBtn" onclick="showSolution2('solution2')">Решение на Пример №2</button>
                <section id="solution2">
                    <p>Така написано, правилата ще са в конфликт. За да се реши този проблем, може правилото за годините да се напише по-конкретно, все пак годините за 4-цифрени числа, и да се изпълни първо. Това би изглеждало така:</p>
                    <p>RewriteRule    ^([0-9]{4})/?$    get_archives_by_year.php?year=$1    [NC,L]    # Get archive by year</p>
                    <p>RewriteRule    ^([A-Za-z0-9-]+)/?$    get_archives_by_topic.php?topic_name=$1    [NC,L]    # Get archive by topic</p>
                </section>
            </section>
        </section>
        <hr>
        <button id="topBtn"><a href="#top" style="color: white">Top</a></button>
    </main>
    <footer>
        <h2 id="resources">Източници</h2>
            <p id="res1">[1] Computer Hope, "What is URL", последно посетен на 12 Apr 2021, [<a href="https://www.computerhope.com/jargon/u/url.htm" target="_blank">https://www.computerhope.com/jargon/u/url.htm</a>]</p>
            <p id="res2">[2] Huify, "What is a URL and How Does it Work?", последно посетен на 12 Apr 2021, [<a href="https://www.huify.com/blog/what-is-a-url-and-how-does-it-work" target="_blank">https://www.huify.com/blog/what-is-a-url-and-how-does-it-work</a>]</p>
            <p id="res3">[3] Alone On A Hill, "URL Rewriting for Beginners", последно посетен на 13 Apr 2021, [<a href="https://aloneonahill.com/blog/url-rewriting-for-beginners/" target="_blank">https://aloneonahill.com/blog/url-rewriting-for-beginners/</a>]</p>
            <p id="res4">[4] Wikipedia, "Rewrite Engine", последно посетен на 12 Apr 2021, [<a href="https://en.wikipedia.org/wiki/Rewrite_engine" target="_blank">https://en.wikipedia.org/wiki/Rewrite_engine</a>]</p>
            <p id="res5">[5] smashingmagazine, "Introduction To URL Rewriting", последно посетен на 13 Apr 2021, [<a href="https://www.smashingmagazine.com/2011/11/introduction-to-url-rewriting/" target="_blank">https://www.smashingmagazine.com/2011/11/introduction-to-url-rewriting/</a>]</p>
            <p id="res6">[6] Apache, "RewriteRule Flags", последно посетен на 13 Apr 2021, [<a href="https://httpd.apache.org/docs/2.4/rewrite/flags.html" target="_blank">https://httpd.apache.org/docs/2.4/rewrite/flags.html</a>]</p>
            <p id="res7">[7] 24 WAYS, "URL Rewriting for the Fearful", последно посетен на 14 Apr 2021, [<a href="https://24ways.org/2013/url-rewriting-for-the-fearful/" target="_blank">https://24ways.org/2013/url-rewriting-for-the-fearful/</a>]</p>
            <p id="res8">[8] perishablepress, "Stupid .htaccess Tricks", последно посетен на 14 Apr 2021, [<a href="https://perishablepress.com/stupid-htaccess-tricks/#gen1" target="_blank">https://perishablepress.com/stupid-htaccess-tricks/#gen1</a>]</p>        
    </footer>
</body>

</html>